// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target x86_64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -module-name Nimble
import CoreFoundation
import CoreGraphics
import Darwin
import Dispatch
import Dispatch/*.DispatchTimeInterval*/
import Foundation
import Foundation/*.ComparisonResult*/
import Foundation/*.NSDictionary*/
import Foundation/*.NSException*/
import Foundation/*.NSExceptionName*/
import Foundation/*.NSFastEnumeration*/
import Foundation/*.NSFastEnumerationIterator*/
import Foundation/*.NSObject*/
import Foundation/*.NSString*/
import Foundation/*.Thread*/
import Foundation/*.TimeInterval*/
@_exported import Nimble
import Swift
import XCTest
import _Concurrency
public protocol AssertionHandler {
  func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation)
}
public var NimbleAssertionHandler: AssertionHandler
public func allPass<S>(_ passFunc: @escaping (S.Element) throws -> Bool) -> Predicate<S> where S : Swift.Sequence
public func allPass<S>(_ passName: String, _ passFunc: @escaping (S.Element) throws -> Bool) -> Predicate<S> where S : Swift.Sequence
public func allPass<S>(_ elementPredicate: Predicate<S.Element>) -> Predicate<S> where S : Swift.Sequence
extension NMBPredicate {
  @objc dynamic public class func allPassMatcher(_ predicate: NMBPredicate) -> NMBPredicate
}
public class AssertionDispatcher : AssertionHandler {
  public init(handlers: [AssertionHandler])
  public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation)
  @objc deinit
}
public struct AssertionRecord : CustomStringConvertible {
  public let success: Bool
  public let message: FailureMessage
  public let location: SourceLocation
  public var description: String {
    get
  }
}
public class AssertionRecorder : AssertionHandler {
  public var assertions: [Nimble.AssertionRecord]
  public init()
  public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation)
  @objc deinit
}
public func withAssertionHandler(_ tempAssertionHandler: AssertionHandler, file: FileString = #file, line: UInt = #line, closure: () throws -> Void)
public func gatherExpectations(silently: Bool = false, closure: () -> Void) -> [AssertionRecord]
public func gatherFailingExpectations(silently: Bool = false, closure: () -> Void) -> [AssertionRecord]
public struct AsyncDefaults {
  public static var timeout: DispatchTimeInterval
  public static var pollInterval: DispatchTimeInterval
}
extension Expectation {
  public func toEventually(_ predicate: Predicate<T>, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  public func toEventuallyNot(_ predicate: Predicate<T>, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  public func toNotEventually(_ predicate: Predicate<T>, timeout: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  public func toNever(_ predicate: Predicate<T>, until: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  public func neverTo(_ predicate: Predicate<T>, until: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  public func toAlways(_ predicate: Predicate<T>, until: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
  public func alwaysTo(_ predicate: Predicate<T>, until: DispatchTimeInterval = AsyncDefaults.timeout, pollInterval: DispatchTimeInterval = AsyncDefaults.pollInterval, description: String? = nil)
}
public func beAKindOf<T>(_ expectedType: T.Type) -> Predicate<Any>
public func beAKindOf(_ expectedClass: AnyClass) -> Predicate<NSObject>
extension NMBPredicate {
  @objc dynamic public class func beAKindOfMatcher(_ expected: AnyClass) -> NMBPredicate
}
public func beAnInstanceOf<T>(_ expectedType: T.Type) -> Predicate<Any>
public func beAnInstanceOf(_ expectedClass: AnyClass) -> Predicate<NSObject>
extension NMBPredicate {
  @objc dynamic public class func beAnInstanceOfMatcher(_ expected: AnyClass) -> NMBPredicate
}
public let DefaultDelta: Double
public func defaultDelta<F>() -> F where F : Swift.FloatingPoint
public func beCloseTo<Value>(_ expectedValue: Value, within delta: Value = defaultDelta()) -> Predicate<Value> where Value : Swift.FloatingPoint
public func beCloseTo<Value>(_ expectedValue: Value, within delta: Double = DefaultDelta) -> Predicate<Value> where Value : Nimble.NMBDoubleConvertible
@objc @_hasMissingDesignatedInitializers public class NMBObjCBeCloseToPredicate : NMBPredicate {
  @objc public var within: (CDouble) -> NMBObjCBeCloseToPredicate {
    @objc get
  }
  @objc deinit
}
extension NMBPredicate {
  @objc dynamic public class func beCloseToMatcher(_ expected: NSNumber, within: CDouble) -> NMBObjCBeCloseToPredicate
}
public func beCloseTo<Value, Values>(_ expectedValues: Values, within delta: Value = defaultDelta()) -> Predicate<Values> where Value : Swift.FloatingPoint, Value == Values.Element, Values : Swift.Collection
infix operator ≈ : ComparisonPrecedence
extension Expectation where T : Swift.Collection, T.Element : Swift.FloatingPoint {
  public static func ≈ (lhs: Expectation, rhs: T)
}
extension Expectation where T : Swift.FloatingPoint {
  public static func ≈ (lhs: Expectation, rhs: T)
  public static func ≈ (lhs: Expectation, rhs: (expected: T, delta: T))
  public static func == (lhs: Expectation, rhs: (expected: T, delta: T))
}
extension Expectation where T : Nimble.NMBDoubleConvertible {
  public static func ≈ (lhs: Expectation, rhs: T)
  public static func ≈ (lhs: Expectation, rhs: (expected: T, delta: Double))
  public static func == (lhs: Expectation, rhs: (expected: T, delta: Double))
}
precedencegroup PlusMinusOperatorPrecedence {
  higherThan: BitwiseShiftPrecedence
}
infix operator ± : PlusMinusOperatorPrecedence
public func ± <Value>(lhs: Value, rhs: Value) -> (expected: Value, delta: Value) where Value : Swift.FloatingPoint
public func ± <Value>(lhs: Value, rhs: Double) -> (expected: Value, delta: Double) where Value : Nimble.NMBDoubleConvertible
public func beEmpty<S>() -> Predicate<S> where S : Swift.Sequence
public func beEmpty<S>() -> Predicate<S> where S : Swift.SetAlgebra
public func beEmpty<S>() -> Predicate<S> where S : Swift.Sequence, S : Swift.SetAlgebra
public func beEmpty() -> Predicate<String>
public func beEmpty() -> Predicate<NSString>
public func beEmpty() -> Predicate<NSDictionary>
public func beEmpty() -> Predicate<NSArray>
public func beEmpty() -> Predicate<NMBCollection>
extension NMBPredicate {
  @objc dynamic public class func beEmptyMatcher() -> NMBPredicate
}
public func beginWith<S>(_ startingElement: S.Element) -> Predicate<S> where S : Swift.Sequence, S.Element : Swift.Equatable
public func beginWith(_ startingElement: Any) -> Predicate<NMBOrderedCollection>
public func beginWith(_ startingSubstring: String) -> Predicate<String>
extension NMBPredicate {
  @objc dynamic public class func beginWithMatcher(_ expected: Any) -> NMBPredicate
}
public func beginWith<Seq1, Seq2>(prefix expectedPrefix: Seq2?) -> Predicate<Seq1> where Seq1 : Swift.Sequence, Seq2 : Swift.Sequence, Seq1.Element : Swift.Equatable, Seq1.Element == Seq2.Element
public func beginWith<Seq1, Seq2>(prefix expectedPrefix: Seq2?, by areEquivalent: @escaping (Seq1.Element, Seq2.Element) -> Bool) -> Predicate<Seq1> where Seq1 : Swift.Sequence, Seq2 : Swift.Sequence
public func beGreaterThan<T>(_ expectedValue: T?) -> Predicate<T> where T : Swift.Comparable
public func > <T>(lhs: Expectation<T>, rhs: T) where T : Swift.Comparable
public func beGreaterThan(_ expectedValue: NMBComparable?) -> Predicate<NMBComparable>
public func > (lhs: Expectation<NMBComparable>, rhs: NMBComparable?)
extension NMBPredicate {
  @objc dynamic public class func beGreaterThanMatcher(_ expected: NMBComparable?) -> NMBPredicate
}
public func beGreaterThanOrEqualTo<T>(_ expectedValue: T?) -> Predicate<T> where T : Swift.Comparable
public func >= <T>(lhs: Expectation<T>, rhs: T) where T : Swift.Comparable
public func beGreaterThanOrEqualTo<T>(_ expectedValue: T?) -> Predicate<T> where T : Nimble.NMBComparable
public func >= <T>(lhs: Expectation<T>, rhs: T) where T : Nimble.NMBComparable
extension NMBPredicate {
  @objc dynamic public class func beGreaterThanOrEqualToMatcher(_ expected: NMBComparable?) -> NMBPredicate
}
public func beIdenticalTo(_ expected: AnyObject?) -> Predicate<AnyObject>
extension Expectation where T == Swift.AnyObject {
  public static func === (lhs: Expectation, rhs: AnyObject?)
  public static func !== (lhs: Expectation, rhs: AnyObject?)
}
public func be(_ expected: AnyObject?) -> Predicate<AnyObject>
extension NMBPredicate {
  @objc dynamic public class func beIdenticalToMatcher(_ expected: NSObject?) -> NMBPredicate
}
public func beLessThan<T>(_ expectedValue: T?) -> Predicate<T> where T : Swift.Comparable
public func < <T>(lhs: Expectation<T>, rhs: T) where T : Swift.Comparable
public func beLessThan(_ expectedValue: NMBComparable?) -> Predicate<NMBComparable>
public func < (lhs: Expectation<NMBComparable>, rhs: NMBComparable?)
extension NMBPredicate {
  @objc dynamic public class func beLessThanMatcher(_ expected: NMBComparable?) -> NMBPredicate
}
public func beLessThanOrEqualTo<T>(_ expectedValue: T?) -> Predicate<T> where T : Swift.Comparable
public func <= <T>(lhs: Expectation<T>, rhs: T) where T : Swift.Comparable
public func beLessThanOrEqualTo<T>(_ expectedValue: T?) -> Predicate<T> where T : Nimble.NMBComparable
public func <= <T>(lhs: Expectation<T>, rhs: T) where T : Nimble.NMBComparable
extension NMBPredicate {
  @objc dynamic public class func beLessThanOrEqualToMatcher(_ expected: NMBComparable?) -> NMBPredicate
}
extension Int8 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension UInt8 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension Int16 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension UInt16 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension Int32 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension UInt32 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension Int64 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension UInt64 : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension Float : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension Double : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension Int : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension UInt : ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
public func beTrue() -> Predicate<Bool>
public func beFalse() -> Predicate<Bool>
public func beTruthy<T>() -> Predicate<T> where T : Swift.Equatable, T : Swift.ExpressibleByBooleanLiteral
public func beFalsy<T>() -> Predicate<T> where T : Swift.Equatable, T : Swift.ExpressibleByBooleanLiteral
extension NMBPredicate {
  @objc dynamic public class func beTruthyMatcher() -> NMBPredicate
  @objc dynamic public class func beFalsyMatcher() -> NMBPredicate
  @objc dynamic public class func beTrueMatcher() -> NMBPredicate
  @objc dynamic public class func beFalseMatcher() -> NMBPredicate
}
public func beNil<T>() -> Predicate<T>
extension Expectation {
  public struct Nil : ExpressibleByNilLiteral {
    public init(nilLiteral: ())
  }
  public static func == (lhs: Expectation, rhs: Expectation.Nil)
  public static func != (lhs: Expectation, rhs: Expectation.Nil)
}
extension NMBPredicate {
  @objc dynamic public class func beNilMatcher() -> NMBPredicate
}
public func beSuccess<Success, Failure>(test: ((Success) -> Void)? = nil) -> Predicate<Result<Success, Failure>> where Failure : Swift.Error
public func beFailure<Success, Failure>(test: ((Failure) -> Void)? = nil) -> Predicate<Result<Success, Failure>> where Failure : Swift.Error
public func beVoid() -> Predicate<()>
extension Expectation where T == () {
  public static func == (lhs: Expectation<()>, rhs: ())
  public static func != (lhs: Expectation<()>, rhs: ())
}
public func beWithin<T>(_ range: Range<T>) -> Predicate<T> where T : Swift.Comparable
public func beWithin<T>(_ range: ClosedRange<T>) -> Predicate<T> where T : Swift.Comparable
public func contain<S>(_ items: S.Element...) -> Predicate<S> where S : Swift.Sequence, S.Element : Swift.Equatable
public func contain<S>(_ items: [S.Element]) -> Predicate<S> where S : Swift.Sequence, S.Element : Swift.Equatable
public func contain<S>(_ items: S.Element...) -> Predicate<S> where S : Swift.SetAlgebra, S.Element : Swift.Equatable
public func contain<S>(_ items: [S.Element]) -> Predicate<S> where S : Swift.SetAlgebra, S.Element : Swift.Equatable
public func contain<S>(_ items: S.Element...) -> Predicate<S> where S : Swift.Sequence, S : Swift.SetAlgebra, S.Element : Swift.Equatable
public func contain<S>(_ items: [S.Element]) -> Predicate<S> where S : Swift.Sequence, S : Swift.SetAlgebra, S.Element : Swift.Equatable
public func contain(_ substrings: String...) -> Predicate<String>
public func contain(_ substrings: [String]) -> Predicate<String>
public func contain(_ substrings: NSString...) -> Predicate<NSString>
public func contain(_ substrings: [NSString]) -> Predicate<NSString>
public func contain(_ items: Any?...) -> Predicate<NMBContainer>
public func contain(_ items: [Any?]) -> Predicate<NMBContainer>
extension NMBPredicate {
  @objc dynamic public class func containMatcher(_ expected: [NSObject]) -> NMBPredicate
}
public func containElementSatisfying<S>(_ predicate: @escaping ((S.Element) -> Bool), _ predicateDescription: String = "") -> Predicate<S> where S : Swift.Sequence
extension NMBPredicate {
  @objc dynamic public class func containElementSatisfyingMatcher(_ predicate: @escaping ((NSObject) -> Bool)) -> NMBPredicate
}
@_hasMissingDesignatedInitializers @objc(BadInstructionException) public class BadInstructionException : NSException {
  @objc required dynamic public init?(coder aDecoder: NSCoder)
  @objc(receiveReply:) public class func receiveReply(_ reply: bad_instruction_exception_reply_t) -> CInt
  @objc deinit
}
public func catchBadInstruction(in block: @escaping () -> Void) -> BadInstructionException?
extension NSException {
  public static func catchException(in block: @escaping () -> Void) -> `Self`?
}
public let MACH_MSG_TYPE_MAKE_SEND: UInt32
public func MACH_MSGH_BITS_REMOTE(_ bits: UInt32) -> UInt32
public func MACH_MSGH_BITS(_ remote: UInt32, _ local: UInt32) -> UInt32
public let nativeThreadState: Swift.Int32
public let nativeThreadStateCount: Swift.UInt32
public let nativeMachExceptionMask: Darwin.exception_mask_t
public let EXC_TYPES_COUNT: Swift.Int
public struct execTypesCountTuple<T> where T : Swift.ExpressibleByIntegerLiteral {
  public var value: (T, T, T, T, T, T, T, T, T, T, T, T, T, T)
  public init()
}
public func expect<T>(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure @escaping () throws -> T?) -> Expectation<T>
public func expect<T>(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure () -> (() throws -> T)) -> Expectation<T>
public func expect<T>(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure () -> (() throws -> T?)) -> Expectation<T>
public func expect(file: FileString = #file, line: UInt = #line, _ expression: @autoclosure () -> (() throws -> Void)) -> Expectation<Void>
public func fail(_ message: String, location: SourceLocation)
public func fail(_ message: String, file: FileString = #file, line: UInt = #line)
public func fail(_ file: FileString = #file, line: UInt = #line)
public func waitUntil(timeout: DispatchTimeInterval = AsyncDefaults.timeout, file: FileString = #file, line: UInt = #line, action: @escaping (@escaping () -> Void) -> Void)
public func elementsEqual<Seq1, Seq2>(_ expectedValue: Seq2?) -> Predicate<Seq1> where Seq1 : Swift.Sequence, Seq2 : Swift.Sequence, Seq1.Element : Swift.Equatable, Seq1.Element == Seq2.Element
public func elementsEqual<Seq1, Seq2>(_ expectedValue: Seq2?, by areEquivalent: @escaping (Seq1.Element, Seq2.Element) -> Bool) -> Predicate<Seq1> where Seq1 : Swift.Sequence, Seq2 : Swift.Sequence
public func endWith<S>(_ endingElement: S.Element) -> Predicate<S> where S : Swift.Sequence, S.Element : Swift.Equatable
public func endWith(_ endingElement: Any) -> Predicate<NMBOrderedCollection>
public func endWith(_ endingSubstring: String) -> Predicate<String>
extension NMBPredicate {
  @objc dynamic public class func endWithMatcher(_ expected: Any) -> NMBPredicate
}
public func equal<T>(_ expectedValue: T) -> Predicate<T> where T : Swift.Equatable
public func equal<T>(_ expectedValue: [T?]) -> Predicate<[T?]> where T : Swift.Equatable
public func equal<T>(_ expectedValue: T?) -> Predicate<T> where T : Swift.Equatable
public func equal<T>(_ expectedValue: Set<T>) -> Predicate<Set<T>> where T : Swift.Hashable
public func equal<T>(_ expectedValue: Set<T>?) -> Predicate<Set<T>> where T : Swift.Hashable
public func equal<T>(_ expectedValue: Set<T>) -> Predicate<Set<T>> where T : Swift.Comparable, T : Swift.Hashable
public func equal<T>(_ expectedValue: Set<T>?) -> Predicate<Set<T>> where T : Swift.Comparable, T : Swift.Hashable
public func equal<K, V>(_ expectedValue: [K : V?]) -> Predicate<[K : V]> where K : Swift.Hashable, V : Swift.Equatable
public func == <T>(lhs: Expectation<T>, rhs: T) where T : Swift.Equatable
public func == <T>(lhs: Expectation<T>, rhs: T?) where T : Swift.Equatable
public func != <T>(lhs: Expectation<T>, rhs: T) where T : Swift.Equatable
public func != <T>(lhs: Expectation<T>, rhs: T?) where T : Swift.Equatable
public func == <T>(lhs: Expectation<[T]>, rhs: [T]?) where T : Swift.Equatable
public func != <T>(lhs: Expectation<[T]>, rhs: [T]?) where T : Swift.Equatable
public func == <T>(lhs: Expectation<Set<T>>, rhs: Set<T>) where T : Swift.Hashable
public func == <T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) where T : Swift.Hashable
public func != <T>(lhs: Expectation<Set<T>>, rhs: Set<T>) where T : Swift.Hashable
public func != <T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) where T : Swift.Hashable
public func == <T>(lhs: Expectation<Set<T>>, rhs: Set<T>) where T : Swift.Comparable, T : Swift.Hashable
public func == <T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) where T : Swift.Comparable, T : Swift.Hashable
public func != <T>(lhs: Expectation<Set<T>>, rhs: Set<T>) where T : Swift.Comparable, T : Swift.Hashable
public func != <T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) where T : Swift.Comparable, T : Swift.Hashable
public func == <T, C>(lhs: Expectation<[T : C]>, rhs: [T : C]?) where T : Swift.Hashable, C : Swift.Equatable
public func != <T, C>(lhs: Expectation<[T : C]>, rhs: [T : C]?) where T : Swift.Hashable, C : Swift.Equatable
extension NMBPredicate {
  @objc dynamic public class func equalMatcher(_ expected: NSObject) -> NMBPredicate
}
public func equal<T1, T2>(_ expectedValue: (T1, T2)?) -> Predicate<(T1, T2)> where T1 : Swift.Equatable, T2 : Swift.Equatable
public func == <T1, T2>(lhs: Expectation<(T1, T2)>, rhs: (T1, T2)?) where T1 : Swift.Equatable, T2 : Swift.Equatable
public func != <T1, T2>(lhs: Expectation<(T1, T2)>, rhs: (T1, T2)?) where T1 : Swift.Equatable, T2 : Swift.Equatable
public func equal<T1, T2, T3>(_ expectedValue: (T1, T2, T3)?) -> Predicate<(T1, T2, T3)> where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable
public func == <T1, T2, T3>(lhs: Expectation<(T1, T2, T3)>, rhs: (T1, T2, T3)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable
public func != <T1, T2, T3>(lhs: Expectation<(T1, T2, T3)>, rhs: (T1, T2, T3)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable
public func equal<T1, T2, T3, T4>(_ expectedValue: (T1, T2, T3, T4)?) -> Predicate<(T1, T2, T3, T4)> where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable
public func == <T1, T2, T3, T4>(lhs: Expectation<(T1, T2, T3, T4)>, rhs: (T1, T2, T3, T4)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable
public func != <T1, T2, T3, T4>(lhs: Expectation<(T1, T2, T3, T4)>, rhs: (T1, T2, T3, T4)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable
public func equal<T1, T2, T3, T4, T5>(_ expectedValue: (T1, T2, T3, T4, T5)?) -> Predicate<(T1, T2, T3, T4, T5)> where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable, T5 : Swift.Equatable
public func == <T1, T2, T3, T4, T5>(lhs: Expectation<(T1, T2, T3, T4, T5)>, rhs: (T1, T2, T3, T4, T5)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable, T5 : Swift.Equatable
public func != <T1, T2, T3, T4, T5>(lhs: Expectation<(T1, T2, T3, T4, T5)>, rhs: (T1, T2, T3, T4, T5)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable, T5 : Swift.Equatable
public func equal<T1, T2, T3, T4, T5, T6>(_ expectedValue: (T1, T2, T3, T4, T5, T6)?) -> Predicate<(T1, T2, T3, T4, T5, T6)> where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable, T5 : Swift.Equatable, T6 : Swift.Equatable
public func == <T1, T2, T3, T4, T5, T6>(lhs: Expectation<(T1, T2, T3, T4, T5, T6)>, rhs: (T1, T2, T3, T4, T5, T6)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable, T5 : Swift.Equatable, T6 : Swift.Equatable
public func != <T1, T2, T3, T4, T5, T6>(lhs: Expectation<(T1, T2, T3, T4, T5, T6)>, rhs: (T1, T2, T3, T4, T5, T6)?) where T1 : Swift.Equatable, T2 : Swift.Equatable, T3 : Swift.Equatable, T4 : Swift.Equatable, T5 : Swift.Equatable, T6 : Swift.Equatable
public struct Expectation<T> {
  public let expression: Expression<T>
  public init(expression: Expression<T>)
  public func verify(_ pass: Bool, _ message: FailureMessage)
  @discardableResult
  public func to(_ predicate: Predicate<T>, description: String? = nil) -> Nimble.Expectation<T>
  @discardableResult
  public func toNot(_ predicate: Predicate<T>, description: String? = nil) -> Nimble.Expectation<T>
  @discardableResult
  public func notTo(_ predicate: Predicate<T>, description: String? = nil) -> Nimble.Expectation<T>
}
indirect public enum ExpectationMessage {
  case expectedActualValueTo(String)
  case expectedCustomValueTo(String, actual: String)
  case expectedTo(String)
  case fail(String)
  case prepends(String, ExpectationMessage)
  case appends(ExpectationMessage, String)
  case details(ExpectationMessage, String)
  public var expectedMessage: String {
    get
  }
  public func appended(message: String) -> ExpectationMessage
  public func appendedBeNilHint() -> ExpectationMessage
  public func appended(details: String) -> ExpectationMessage
  public func replacedExpectation(_ f: @escaping (ExpectationMessage) -> ExpectationMessage) -> ExpectationMessage
  public func wrappedExpectation(before: String, after: String) -> ExpectationMessage
  public func prepended(expectation message: String) -> ExpectationMessage
  public func toString(actual: String, expected: String = "expected", to: String = "to") -> String
}
@objc @_hasMissingDesignatedInitializers public class NMBExpectationMessage : NSObject {
  public init(expectedTo message: String)
  public init(expectedActualValueTo message: String)
  public init(expectedActualValueTo message: String, customActualValue actual: String)
  public init(fail message: String)
  public init(prepend message: String, child: NMBExpectationMessage)
  public init(appendedMessage message: String, child: NMBExpectationMessage)
  public init(prependedMessage message: String, child: NMBExpectationMessage)
  public init(details message: String, child: NMBExpectationMessage)
  public func appendedBeNilHint() -> NMBExpectationMessage
  public func toSwift() -> ExpectationMessage
  @objc deinit
}
public struct Expression<T> {
  public let location: SourceLocation
  public let isClosure: Bool
  public init(expression: @escaping () throws -> T?, location: SourceLocation, isClosure: Bool = true)
  public init(memoizedExpression: @escaping (Bool) throws -> T?, location: SourceLocation, withoutCaching: Bool, isClosure: Bool = true)
  public func cast<U>(_ block: @escaping (T?) throws -> U?) -> Expression<U>
  public func evaluate() throws -> T?
  public func withoutCaching() -> Expression<T>
}
@objc @_inheritsConvenienceInitializers public class FailureMessage : NSObject {
  public var expected: String
  public var actualValue: String?
  public var to: String
  public var postfixMessage: String
  public var postfixActual: String
  public var extendedMessage: String?
  public var userDescription: String?
  public var stringValue: String {
    get
    set
  }
  @objc override dynamic public init()
  public init(stringValue: String)
  @objc deinit
}
public func haveCount<T>(_ expectedValue: Int) -> Predicate<T> where T : Swift.Collection
public func haveCount(_ expectedValue: Int) -> Predicate<NMBCollection>
extension NMBPredicate {
  @objc dynamic public class func haveCountMatcher(_ expected: NSNumber) -> NMBPredicate
}
public func match(_ expectedValue: String?) -> Predicate<String>
extension NMBPredicate {
  @objc dynamic public class func matchMatcher(_ expected: NSString) -> NMBPredicate
}
public protocol NMBContainer {
  func contains(_ anObject: Any) -> Bool
}
extension NSArray : NMBContainer {
}
extension NSSet : NMBContainer {
}
public protocol NMBCollection {
  var count: Int { get }
}
extension NSHashTable : NMBCollection {
}
extension NSMapTable : NMBCollection {
}
extension NSSet : NMBCollection {
}
extension NSIndexSet : NMBCollection {
}
extension NSDictionary : NMBCollection {
}
public protocol NMBOrderedCollection : Nimble.NMBCollection {
  func object(at index: Int) -> Any
}
extension NSArray : NMBOrderedCollection {
}
public protocol NMBDoubleConvertible {
  var doubleValue: CDouble { get }
}
extension NSNumber : NMBDoubleConvertible {
}
extension Date : NMBDoubleConvertible {
  public var doubleValue: CDouble {
    get
  }
}
extension NSDate : NMBDoubleConvertible {
  public var doubleValue: CDouble {
    get
  }
}
extension Date : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension NSDate : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
@objc public protocol NMBComparable {
  @objc func NMB_compare(_ otherObject: NMBComparable!) -> ComparisonResult
}
extension NSNumber : NMBComparable {
  @objc dynamic public func NMB_compare(_ otherObject: NMBComparable!) -> ComparisonResult
}
extension NSString : NMBComparable {
  @objc dynamic public func NMB_compare(_ otherObject: NMBComparable!) -> ComparisonResult
}
public func matchError<T>(_ error: T) -> Predicate<Error> where T : Swift.Error
public func matchError<T>(_ error: T) -> Predicate<Error> where T : Swift.Equatable, T : Swift.Error
public func matchError<T>(_ errorType: T.Type) -> Predicate<Error> where T : Swift.Error
@_hasMissingDesignatedInitializers public class NimbleXCTestHandler : AssertionHandler {
  public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class NimbleShortXCTestHandler : AssertionHandler {
  public func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation)
  @objc deinit
}
public func recordFailure(_ message: String, location: SourceLocation)
@objc public class NMBExpectation : NSObject {
  @objc public init(actualBlock: @escaping () -> NSObject?, negative: Bool, file: FileString, line: UInt)
  @objc public var withTimeout: (TimeInterval) -> NMBExpectation {
    @objc get
  }
  @objc public var to: (NMBPredicate) -> NMBExpectation {
    @objc get
  }
  @objc public var toWithDescription: (NMBPredicate, String) -> NMBExpectation {
    @objc get
  }
  @objc public var toNot: (NMBPredicate) -> NMBExpectation {
    @objc get
  }
  @objc public var toNotWithDescription: (NMBPredicate, String) -> NMBExpectation {
    @objc get
  }
  @objc public var notTo: (NMBPredicate) -> NMBExpectation {
    @objc get
  }
  @objc public var notToWithDescription: (NMBPredicate, String) -> NMBExpectation {
    @objc get
  }
  @objc public var toEventually: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var toEventuallyWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public var toEventuallyNot: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var toEventuallyNotWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public var toNotEventually: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var toNotEventuallyWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public var toNever: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var toNeverWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public var neverTo: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var neverToWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public var toAlways: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var toAlwaysWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public var alwaysTo: (NMBPredicate) -> Void {
    @objc get
  }
  @objc public var alwaysToWithDescription: (NMBPredicate, String) -> Void {
    @objc get
  }
  @objc public class func failWithMessage(_ message: String, file: FileString, line: UInt)
  @objc deinit
}
public func postNotifications<Out>(_ predicate: Predicate<[Notification]>, from center: NotificationCenter = .default) -> Predicate<Out>
public struct Predicate<T> {
  public init(_ matcher: @escaping (Expression<T>) throws -> PredicateResult)
  public func satisfies(_ expression: Expression<T>) throws -> PredicateResult
}
extension Predicate {
  public static func define(matcher: @escaping (Expression<T>) throws -> PredicateResult) -> Predicate<T>
  public static func define(_ message: String = "match", matcher: @escaping (Expression<T>, ExpectationMessage) throws -> PredicateResult) -> Predicate<T>
  public static func defineNilable(_ message: String = "match", matcher: @escaping (Expression<T>, ExpectationMessage) throws -> PredicateResult) -> Predicate<T>
}
extension Predicate {
  public static func simple(_ message: String = "match", matcher: @escaping (Expression<T>) throws -> PredicateStatus) -> Predicate<T>
  public static func simpleNilable(_ message: String = "match", matcher: @escaping (Expression<T>) throws -> PredicateStatus) -> Predicate<T>
}
public enum ExpectationStyle {
  case toMatch, toNotMatch
  public static func == (a: Nimble.ExpectationStyle, b: Nimble.ExpectationStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PredicateResult {
  public var status: PredicateStatus
  public var message: ExpectationMessage
  public init(status: PredicateStatus, message: ExpectationMessage)
  public init(bool: Bool, message: ExpectationMessage)
  public func toBoolean(expectation style: ExpectationStyle) -> Bool
}
public enum PredicateStatus {
  case matches
  case doesNotMatch
  case fail
  public init(bool matches: Bool)
  public static func == (a: Nimble.PredicateStatus, b: Nimble.PredicateStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Predicate {
  public var requireNonNil: Predicate<T> {
    get
  }
}
public typealias PredicateBlock = (_ actualExpression: Expression<NSObject>) throws -> NMBPredicateResult
@objc public class NMBPredicate : NSObject {
  public init(predicate: @escaping PredicateBlock)
  @objc deinit
}
@objc final public class NMBPredicateResult : NSObject {
  final public var status: NMBPredicateStatus
  final public var message: NMBExpectationMessage
  public init(status: NMBPredicateStatus, message: NMBExpectationMessage)
  public init(bool success: Bool, message: NMBExpectationMessage)
  final public func toSwift() -> PredicateResult
  @objc deinit
}
extension PredicateResult {
  public func toObjectiveC() -> NMBPredicateResult
}
@objc @_hasMissingDesignatedInitializers final public class NMBPredicateStatus : NSObject {
  public static let matches: NMBPredicateStatus
  public static let doesNotMatch: NMBPredicateStatus
  public static let fail: NMBPredicateStatus
  @objc override final public var hash: Int {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Bool
  public static func from(status: PredicateStatus) -> NMBPredicateStatus
  public static func from(bool success: Bool) -> NMBPredicateStatus
  final public func toSwift() -> PredicateStatus
  @objc deinit
}
extension PredicateStatus {
  public func toObjectiveC() -> NMBPredicateStatus
}
public func raiseException<Out>(named: NSExceptionName? = nil, reason: String? = nil, userInfo: NSDictionary? = nil, closure: ((NSException) -> Void)? = nil) -> Predicate<Out>
public func raiseException<Out>(named: String?, reason: String? = nil, userInfo: NSDictionary? = nil, closure: ((NSException) -> Void)? = nil) -> Predicate<Out>
@objc @_hasMissingDesignatedInitializers public class NMBObjCRaiseExceptionPredicate : NMBPredicate {
  @objc public var named: (_ name: String) -> NMBObjCRaiseExceptionPredicate {
    @objc get
  }
  @objc public var reason: (_ reason: String?) -> NMBObjCRaiseExceptionPredicate {
    @objc get
  }
  @objc public var userInfo: (_ userInfo: NSDictionary?) -> NMBObjCRaiseExceptionPredicate {
    @objc get
  }
  @objc public var satisfyingBlock: (_ block: ((NSException) -> Void)?) -> NMBObjCRaiseExceptionPredicate {
    @objc get
  }
  @objc deinit
}
extension NMBPredicate {
  @objc dynamic public class func raiseExceptionMatcher() -> NMBObjCRaiseExceptionPredicate
}
public func satisfyAllOf<T>(_ predicates: Predicate<T>...) -> Predicate<T>
public func satisfyAllOf<T>(_ predicates: [Predicate<T>]) -> Predicate<T>
public func && <T>(left: Predicate<T>, right: Predicate<T>) -> Predicate<T>
extension NMBPredicate {
  @objc dynamic public class func satisfyAllOfMatcher(_ predicates: [NMBPredicate]) -> NMBPredicate
}
public func satisfyAnyOf<T>(_ predicates: Predicate<T>...) -> Predicate<T>
public func satisfyAnyOf<T>(_ predicates: [Predicate<T>]) -> Predicate<T>
public func || <T>(left: Predicate<T>, right: Predicate<T>) -> Predicate<T>
extension NMBPredicate {
  @objc dynamic public class func satisfyAnyOfMatcher(_ predicates: [NMBPredicate]) -> NMBPredicate
}
public typealias FileString = String
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SourceLocation : NSObject {
  final public let file: FileString
  final public let line: UInt
  @objc override final public var description: String {
    @objc get
  }
  @objc deinit
}
public protocol TestOutputStringConvertible {
  var testDescription: String { get }
}
extension Double : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension Float : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension NSNumber : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension Array : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension AnySequence : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension NSArray : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension NSIndexSet : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension String : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
extension Data : TestOutputStringConvertible {
  public var testDescription: String {
    get
  }
}
public func stringify<T>(_ value: T?) -> String
@_inheritsConvenienceInitializers @objc public class NMBStringer : NSObject {
  @objc public class func stringify(_ obj: Any?) -> String
  @objc override dynamic public init()
  @objc deinit
}
public func prettyCollectionType<T>(_ value: T) -> String
public func prettyCollectionType<T>(_ collection: T) -> String where T : Swift.Collection
public func throwAssertion<Out>() -> Predicate<Out>
public func throwError<Out>() -> Predicate<Out>
public func throwError<T, Out>(_ error: T, closure: ((Error) -> Void)? = nil) -> Predicate<Out> where T : Swift.Error
public func throwError<T, Out>(_ error: T, closure: ((T) -> Void)? = nil) -> Predicate<Out> where T : Swift.Equatable, T : Swift.Error
public func throwError<T, Out>(errorType: T.Type, closure: ((T) -> Void)? = nil) -> Predicate<Out> where T : Swift.Error
public func throwError<Out>(closure: @escaping ((Error) -> Void)) -> Predicate<Out>
public func throwError<T, Out>(closure: @escaping ((T) -> Void)) -> Predicate<Out> where T : Swift.Error
public enum ToSucceedResult {
  case succeeded
  case failed(reason: String)
}
public func succeed() -> Predicate<ToSucceedResult>
extension Nimble.ExpectationStyle : Swift.Equatable {}
extension Nimble.ExpectationStyle : Swift.Hashable {}
extension Nimble.PredicateStatus : Swift.Equatable {}
extension Nimble.PredicateStatus : Swift.Hashable {}
